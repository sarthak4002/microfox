import { z } from 'zod';
import fs from 'fs';
import path from 'path';

export const ReadMeObject = z.object({
  path: z
    .string()
    .startsWith('https://')
    .describe(
      'The complete path to the README file in the package or outside the package',
    ),
  type: z
    .enum(['main', 'constructor', 'functionality'])
    .describe('The type of the README file'),
  extension: z
    .enum(['md', 'txt', 'html'])
    .describe('The extension of the README file'),
  functionality: z
    .string()
    .optional()
    .describe('The functionality this README file explains on how to use'),
  description: z
    .string()
    .optional()
    .describe(
      'The description of the functionality this README file explains on how to use',
    ),
});

export const PackageReadmeMap = z
  .object({
    path: z
      .string()
      .describe('The path to the main README file in the package'),
    functionalities: z
      .array(z.string())
      .describe('The functionalities of the package'),
    all_readmes: z
      .array(ReadMeObject)
      .optional()
      .describe('The main readmes of the package'),
    description: z.string().describe('The description of the package'),
  })
  .refine(
    data => {
      // If all_readmes is not provided, validation passes
      if (!data.all_readmes) return true;

      // Check if any functionality in all_readmes exists in functionalities
      return data.all_readmes.every(readme => {
        // If readme doesn't have a functionality field, it's valid
        if (!readme.functionality) return true;

        // Check if the functionality exists in the functionalities array
        return data.functionalities.includes(readme.functionality);
      });
    },
    {
      message:
        'Each functionality specified in all_readmes must exist in the functionalities array',
      path: ['all_readmes'],
    },
  );

export const Instructions = z.object({
  type: z.enum(['video', 'image', 'externalLink']),
  url: z.string().url(),
  placement: z.enum(['onCopy', 'onHowToGet']).optional(),
});

export const KeyInfo = z.object({
  key: z.string().describe('The key of the constructor'),
  displayName: z.string().describe('The display name of the key'),
  description: z.string().describe('The description of the key'),
  defaultValue: z
    .string()
    .or(z.array(z.string()))
    .or(z.number())
    .or(z.array(z.number()))
    .or(z.boolean())
    .optional()
    .describe('The default value of the key'),
  instructions: Instructions.optional(),
});

export const KeyInfoWithUi = KeyInfo.extend({
  ui: z.object({
    type: z.enum([
      'text',
      'number',
      'boolean',
      'select',
      'multiSelect',
      'textarea',
      'image',
      'autogeneratedToken',
    ]),
    options: z
      .array(z.object({ label: z.string(), value: z.string() }))
      .optional(),
    placeholder: z.string().optional(),
    label: z.string().optional(),
    required: z.boolean().optional(),
    isPrefilled: z.boolean().optional(),
    isUnique: z.boolean().optional(),
    disabled: z.boolean().optional(),
  }),
});

export const Constructor = z
  .object({
    name: z.string().describe('The name of the constructor'),
    description: z.string().describe('The description of the constructor'),
    auth: z
      .enum(['oauth2', 'apikey'])
      .describe('The authentication method of the constructor'),
    authEndpoint: z
      .string()
      .optional()
      .describe('The endpoint of the constructor'),
    requiredKeys: z
      .array(KeyInfo)
      .describe('The required keys of the constructor'),
    isAutoSetupEnabled: z.boolean().optional(),
    requiredKeysInstructions: Instructions.optional(),
    requiredKeysComponent: z.string().optional(),
    internalKeys: z
      .array(KeyInfo)
      .describe('The oauth2 keys of the constructor'),
    functionalities: z
      .array(z.string())
      .default([])
      .describe('The functionalities of the constructor'),
    botConfig: z
      .array(KeyInfoWithUi)
      .default([])
      .describe('The bot config of the constructor'),
    botConfigInstructions: Instructions.optional(),
    botConfigComponent: z.string().optional(),
    apiType: z
      .enum(['bot_token', 'api_key'])
      .optional()
      .describe('The type of the API'),
  })
  .refine(
    data => {
      // If auth is 'apikey', apiType must be provided
      if (data.auth === 'apikey') {
        return data.apiType !== undefined;
      }
      return true;
    },
    {
      message: "apiType is required when auth is 'apikey'",
      path: ['apiType'],
    },
  );

export type Constructor = z.infer<typeof Constructor>;

export const PackageInfo = z
  .object({
    name: z
      .string()
      .startsWith('@')
      .describe('The name of the package - @slack/web-api or @microfox/slack'),
    title: z
      .string()
      .describe('Display name of the package')
      .refine(value => !value.startsWith('@'), {
        message: 'Title must not start with "@"',
      }),
    authEndpoint: z.string().optional(),
    authType: z.enum(['oauth2', 'apikey', 'none']).optional(),
    oauth2Scopes: z.array(z.string()).optional(),
    description: z.string().describe('One line Description of the package'),
    path: z
      .string()
      .describe(
        'The path to the package in the monorepo - packages/@ext_@slack#web-api or packages/slack',
      )
      .refine(
        value =>
          value.startsWith('packages/@ext_') || value.startsWith('packages/'),
        {
          message:
            'Path must start with either "packages/@ext_" or "packages/"',
        },
      ),
    dependencies: z
      .array(z.string())
      .describe('The dependencies of the package'),
    status: z
      .enum([
        'stable',
        'external',
        'semiStable',
        'unstable',
        'oauthConnector',
        'internal',
      ])
      .describe('The status of the package'),
    documentation: z.string().describe('The documentation of the package'),
    icon: z
      .string()
      .describe('The icon url of the package')
      .startsWith('https://'),
    readme_map: PackageReadmeMap,
    constructors: z.array(Constructor),
    keysInfo: z.array(
      KeyInfo.partial({ displayName: true, description: true }).extend({
        constructors: z.array(z.string()),
        required: z.boolean().optional(),
      }),
    ),
    keyInstructions: z
      .object({
        link: z.string().url(),
        setupInfo: z.string().optional(),
      })
      .optional(),
    extraInfo: z.array(z.string()),
  })
  .refine(
    data => {
      // If all_readmes is not provided, validation passes
      if (data.status === 'external') {
        // data.path must start with packages/ext_
        if (!data.path.startsWith('packages/@ext_')) {
          return false;
        }
      }
      if (data.status === 'stable') {
        // data.path must start with packages/@microfox
        if (data.path.startsWith('packages/@ext_')) {
          return false;
        }
      }
      return true;
    },
    {
      message: `The path of the package must start with packages/@ext_ for external packages and packages/ for stable packages`,
      path: ['path'],
    },
  )
  .refine(
    data => {
      if (data.status !== 'stable' && data.status !== 'external') return true;
      // If the icon is a GitHub raw URL from our repository
      if (
        data.icon.includes('raw.githubusercontent.com/microfox-ai/microfox')
      ) {
        try {
          // Extract the path after the repository name
          const pathInRepo = data.icon.split('microfox/refs/heads/main/')[1];
          if (!pathInRepo) return false;

          // Resolve the path relative to the workspace root
          const workspaceRoot = path.resolve(__dirname, '..', '..');
          const localPath = path.join(workspaceRoot, pathInRepo);

          return fs.existsSync(localPath);
        } catch (error) {
          return false;
        }
      }
      // For external URLs, just validate that it's a valid HTTPS URL
      return data.icon.startsWith('https://');
    },
    {
      message: `The icon must be either a valid HTTPS URL or a valid path to an existing file in the repository`,
      path: ['icon'],
    },
  );

export type PackageInfo = z.infer<typeof PackageInfo>;
